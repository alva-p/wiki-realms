{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Alvaro/Desktop/Proyectos/wiki-realms/lib/lastsales.ts"],"sourcesContent":["import fs from 'fs'\r\nimport path from 'path'\r\n\r\nconst DATA_PATH = path.resolve(process.cwd(), 'data', 'lastsales.json')\r\n\r\nexport type Trait = { trait_type: string; value: string }\r\n\r\nexport type Sale = {\r\n  id: string\r\n  collection: string\r\n  tokenId?: string\r\n  price: number\r\n  currency?: string\r\n  date: string\r\n  traits?: Trait[]\r\n}\r\n\r\ntype Stored = {\r\n  last_timestamps: Record<string, number>\r\n  sales: Sale[]\r\n  last_refresh?: number\r\n}\r\n\r\nfunction ensureDataFile() {\r\n  const dir = path.dirname(DATA_PATH)\r\n  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true })\r\n  if (!fs.existsSync(DATA_PATH)) {\r\n    const initial: Stored = { last_timestamps: {}, sales: [], last_refresh: 0 }\r\n    fs.writeFileSync(DATA_PATH, JSON.stringify(initial, null, 2))\r\n  }\r\n}\r\n\r\nexport function readStored(): Stored {\r\n  ensureDataFile()\r\n  const raw = fs.readFileSync(DATA_PATH, 'utf-8')\r\n  try {\r\n    const parsed = JSON.parse(raw) as Stored\r\n    if (typeof parsed.last_refresh !== 'number') parsed.last_refresh = 0\r\n    return parsed\r\n  } catch (err) {\r\n    const initial: Stored = { last_timestamps: {}, sales: [], last_refresh: 0 }\r\n    return initial\r\n  }\r\n}\r\n\r\nexport function writeStored(data: Stored) {\r\n  ensureDataFile()\r\n  if (typeof data.last_refresh !== 'number') data.last_refresh = 0\r\n  fs.writeFileSync(DATA_PATH, JSON.stringify(data, null, 2))\r\n}\r\n\r\n/**\r\n * Fetch sales from OpenSea events endpoint and normalize them to Sale[]\r\n */\r\nexport async function fetchOpenSeaSales(contract: string, occurredAfterUnix = 0, apiKey?: string): Promise<Sale[]> {\r\n  if (!contract) return []\r\n  if (!process.env.OPENSEA_API_URL) {\r\n    // default OpenSea events endpoint alternative\r\n    process.env.OPENSEA_API_URL = 'https://api.opensea.io/api/v1/events'\r\n  }\r\n  const base = process.env.OPENSEA_API_URL\r\n  const url = new URL(base)\r\n  // prefer query by collection slug; if contract looks like address, set asset_contract_address\r\n  if (contract && contract.startsWith('0x')) url.searchParams.set('asset_contract_address', contract)\r\n  else url.searchParams.set('collection_slug', contract)\r\n  url.searchParams.set('event_type', 'sale')\r\n  if (occurredAfterUnix) url.searchParams.set('occurred_after', String(occurredAfterUnix))\r\n  url.searchParams.set('limit', '50')\r\n\r\n  const headers: Record<string, string> = {}\r\n  if (apiKey) headers['X-API-KEY'] = apiKey\r\n\r\n  const res = await fetch(url.toString(), { headers })\r\n  if (!res.ok) throw new Error(`OpenSea fetch failed: ${res.status}`)\r\n  const data = await res.json()\r\n\r\n  const events = data?.events || data?.asset_events || []\r\n  const out: Sale[] = events.map((event: any) => {\r\n    const tokenId = event?.nft?.identifier || event?.nft?.token_id || (event?.nft?.tokenId && String(event.nft.tokenId)) || undefined\r\n    const price = event?.payment?.quantity ? Number(event.payment.quantity) / Math.pow(10, 18) : (event?.price ? Number(event.price) : 0)\r\n    const maker = event?.from_account?.address || event?.seller || undefined\r\n    const matcher = event?.to_account?.address || event?.buyer || undefined\r\n    const ts = event?.event_timestamp || event?.created_date || event?.timestamp\r\n    const txHash = event?.transaction_hash || event?.txHash || event?.transaction?.transaction_hash\r\n    const image = event?.nft?.image_url || event?.nft?.image || event?.image\r\n\r\n    return {\r\n      id: String(event.id || txHash || `${contract}-${tokenId}-${ts}`),\r\n      collection: event?.collection?.slug || event?.nft?.collection?.slug || contract,\r\n      tokenId: tokenId != null ? String(tokenId) : undefined,\r\n      price: Number.isFinite(price) ? price : 0,\r\n      currency: event?.payment?.token_symbol || event?.payment?.symbol || event?.payment_token?.symbol || 'ETH',\r\n      date: ts || new Date().toISOString(),\r\n      traits: [],\r\n      // extra fields\r\n      // @ts-ignore\r\n      maker,\r\n      // @ts-ignore\r\n      matcher,\r\n      // @ts-ignore\r\n      txHash,\r\n      // @ts-ignore\r\n      image,\r\n    }\r\n  })\r\n\r\n  return out\r\n}\r\n\r\n/**\r\n * Fetch recent transfer logs from Ronin RPC as a proxy for sales.\r\n * This is a best-effort approach: Ronin doesn't expose a unified \"sales\" REST like OpenSea.\r\n * We scan recent blocks for ERC-721 Transfer events for the contract and return them as Sale[]\r\n */\r\nexport async function fetchRoninSales(contract: string, occurredAfterUnix = 0, rpcUrl?: string): Promise<Sale[]> {\r\n  if (!contract || !rpcUrl) return []\r\n\r\n  // Helper to call JSON-RPC\r\n  async function rpc(method: string, params: any[]) {\r\n    const res = await fetch(rpcUrl!, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params }),\r\n    })\r\n    const j = await res.json()\r\n    return j.result\r\n  }\r\n\r\n  // get latest block\r\n  const latestHex = await rpc('eth_blockNumber', [])\r\n  const latest = parseInt(latestHex, 16)\r\n  // scan last N blocks (configurable); 20000 ~ ~ a few days depending on chain\r\n  const SCAN_BLOCKS = 20000\r\n  const fromBlock = Math.max(0, latest - SCAN_BLOCKS)\r\n\r\n  // eth_getLogs params without topics (some providers restrict topics)\r\n  const paramsNoTopic = [{ address: contract, fromBlock: '0x' + fromBlock.toString(16), toBlock: '0x' + latest.toString(16) }]\r\n\r\n  let logs: any[] = []\r\n  try {\r\n    logs = await rpc('eth_getLogs', paramsNoTopic)\r\n  } catch (err) {\r\n    return []\r\n  }\r\n\r\n  const results: Sale[] = []\r\n  for (const log of logs) {\r\n    try {\r\n      if (!log.topics || log.topics.length === 0) continue\r\n      if (!log.topics[0].startsWith('0xddf252ad')) continue // Transfer signature prefix\r\n\r\n      // tokenId usually in topics[3] or in data\r\n      let tokenIdHex = log.topics[3] || log.data\r\n      if (!tokenIdHex) continue\r\n      tokenIdHex = tokenIdHex.startsWith('0x') ? tokenIdHex.slice(2) : tokenIdHex\r\n      tokenIdHex = tokenIdHex.slice(-64)\r\n      const tokenId = BigInt('0x' + tokenIdHex).toString()\r\n\r\n      // get block timestamp\r\n      const block = await rpc('eth_getBlockByNumber', [log.blockNumber, false])\r\n      const ts = block?.timestamp ? parseInt(block.timestamp, 16) : undefined\r\n      if (!ts) continue\r\n      const dateMs = ts * 1000\r\n      if (occurredAfterUnix && ts <= occurredAfterUnix) continue\r\n\r\n      results.push({\r\n        id: `${contract}-${log.transactionHash}-${tokenId}`,\r\n        collection: contract,\r\n        tokenId,\r\n        price: 0,\r\n        currency: 'RONIN',\r\n        date: new Date(dateMs).toISOString(),\r\n        traits: [],\r\n      })\r\n    } catch (e) {\r\n      continue\r\n    }\r\n  }\r\n\r\n  results.sort((a, b) => Date.parse(b.date) - Date.parse(a.date))\r\n  return results\r\n}\r\n\r\n/**\r\n * Fetch recent sales from Ronin GraphQL (mavis marketplace) using the provided query.\r\n * Returns an array of Sale normalized objects.\r\n */\r\nexport async function fetchRoninGraphQLSales(contract: string, apiUrl?: string, apiKey?: string, size = 50, from_ = 0, debug = false): Promise<Sale[]> {\r\n  if (!contract || !apiUrl) return []\r\n  const query = `\r\n    query RecentSales($tokenAddress: String!, $from: Int!, $size: Int!) {\r\n      recentlySolds(from: $from, size: $size, tokenAddress: $tokenAddress) {\r\n        results {\r\n          assets {\r\n            token {\r\n              __typename\r\n              ... on Erc1155 {\r\n                tokenIdNum: tokenId\r\n                name\r\n                image\r\n              }\r\n              ... on Erc721 {\r\n                tokenIdStr: tokenId\r\n                name\r\n                image\r\n              }\r\n            }\r\n            quantity\r\n          }\r\n          maker\r\n          matcher\r\n          realPrice\r\n          timestamp\r\n          txHash\r\n        }\r\n      }\r\n    }\r\n  `\r\n\r\n  const variables = { tokenAddress: contract, from: from_, size }\r\n  const headers: Record<string, string> = { 'Content-Type': 'application/json' }\r\n  if (apiKey) headers['x-api-key'] = apiKey\r\n\r\n  const res = await fetch(apiUrl, { method: 'POST', headers, body: JSON.stringify({ query, variables }) })\r\n  if (!res.ok) {\r\n    const body = await res.text()\r\n    throw new Error(`GraphQL HTTP ${res.status}: ${body}`)\r\n  }\r\n\r\n  const data = await res.json()\r\n  if (debug) {\r\n    try { console.debug('fetchRoninGraphQLSales raw:', JSON.stringify(data).slice(0, 2000)) } catch (e) {}\r\n  }\r\n  if (data.errors) {\r\n    throw new Error(`GraphQL errors: ${JSON.stringify(data.errors)}`)\r\n  }\r\n\r\n  const items = (data?.data?.recentlySolds?.results) || []\r\n  const out: Sale[] = []\r\n  for (const it of items) {\r\n    try {\r\n      const asset = it?.assets?.[0]\r\n      const token = asset?.token\r\n      const tokenId = token?.tokenIdNum ?? token?.tokenIdStr ?? token?.tokenId ?? null\r\n      const txHash = it?.txHash || `${contract}-${tokenId}-${it?.timestamp}`\r\n      const price = it?.realPrice ? Number(it.realPrice) / 1e18 : 0\r\n      const ts = it?.timestamp ? Number(it.timestamp) : undefined\r\n      const date = ts ? (ts > 1e12 ? new Date(ts).toISOString() : new Date(ts * 1000).toISOString()) : new Date().toISOString()\r\n      const image = token?.image || asset?.image || null\r\n      const name = token?.name || null\r\n      const maker = it?.maker || null\r\n      const matcher = it?.matcher || null\r\n      const quantity = asset?.quantity ?? null\r\n\r\n      out.push({\r\n        id: String(txHash),\r\n        collection: contract,\r\n        tokenId: tokenId != null ? String(tokenId) : undefined,\r\n        price,\r\n        currency: 'RONIN',\r\n        date,\r\n        traits: [],\r\n        // attach rawFields to allow UI access to extra fields\r\n        // @ts-ignore\r\n        txHash,\r\n        // @ts-ignore\r\n        maker,\r\n        // @ts-ignore\r\n        matcher,\r\n        // @ts-ignore\r\n        image,\r\n        // @ts-ignore\r\n        name,\r\n        // @ts-ignore\r\n        quantity\r\n      })\r\n    } catch (e) {\r\n      continue\r\n    }\r\n  }\r\n\r\n  return out\r\n}\r\n\r\n/**\r\n * Refresh all configured collections. The COLLECTIONS list should be provided by the caller\r\n * as an array of { name, contract, market, last_timestamp? }.\r\n */\r\nexport async function refreshCollections(collections: { name?: string; contract?: string; market?: string; last_timestamp?: number }[], apiKey?: string) {\r\n  const stored = readStored()\r\n\r\n  for (const col of collections) {\r\n    const key = col.contract || col.name || 'unknown'\r\n    const last = stored.last_timestamps[key] || (col.last_timestamp || 0)\r\n\r\n    try {\r\n      const events = await fetchOpenSeaSales(col.contract || '', last, apiKey)\r\n      if (!events.length) continue\r\n\r\n      // append new events (avoid duplicates by id)\r\n      const existingIds = new Set(stored.sales.map((s) => s.id))\r\n      const toAdd = events.filter((e) => !existingIds.has(e.id))\r\n      stored.sales = [...toAdd, ...stored.sales].slice(0, 5000) // cap\r\n\r\n      // update last timestamp to newest event\r\n      const newest = Math.max(...events.map((e) => Date.parse(e.date) / 1000 || 0))\r\n      stored.last_timestamps[key] = Math.max(stored.last_timestamps[key] || 0, newest)\r\n    } catch (err) {\r\n      // swallow per-collection errors so one failure doesn't stop the whole refresh\r\n      // In production log this properly\r\n      // console.error('refreshCollections error', err)\r\n    }\r\n  }\r\n\r\n  stored.last_refresh = Math.floor(Date.now() / 1000)\r\n  writeStored(stored)\r\n  return stored\r\n}\r\n\r\nexport default {\r\n  readStored,\r\n  writeStored,\r\n  fetchOpenSeaSales,\r\n  refreshCollections,\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Alvaro/Desktop/Proyectos/wiki-realms/lib/lastsales-config.ts"],"sourcesContent":["export const CONTRACT_KOJINS = process.env.CONTRACT_ADDRESS_KOJINS\r\nexport const CONTRACT_MOUNTS = process.env.CONTRACT_ADDRESS_MOUNTS\r\nexport const OPENSEA_KEY = process.env.OPENSEA_API_KEY\r\nexport const RONIN_API = process.env.RONIN_API_URL\r\nexport const RONIN_API_KEY = process.env.API_KEY\r\n\r\nexport const COLLECTIONS = [\r\n  { name: 'Kojins', contract: CONTRACT_KOJINS, market: 'opensea' },\r\n  { name: 'Mounts', contract: CONTRACT_MOUNTS, market: 'opensea' },\r\n  { name: 'Kojins', contract: CONTRACT_KOJINS, market: 'ronin' },\r\n  { name: 'Mounts', contract: CONTRACT_MOUNTS, market: 'ronin' },\r\n]\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAO,MAAM,kBAAkB,QAAQ,GAAG,CAAC,uBAAuB;AAC3D,MAAM,kBAAkB,QAAQ,GAAG,CAAC,uBAAuB;AAC3D,MAAM,cAAc,QAAQ,GAAG,CAAC,eAAe;AAC/C,MAAM,YAAY,QAAQ,GAAG,CAAC,aAAa;AAC3C,MAAM,gBAAgB,QAAQ,GAAG,CAAC,OAAO;AAEzC,MAAM,cAAc;IACzB;QAAE,MAAM;QAAU,UAAU;QAAiB,QAAQ;IAAU;IAC/D;QAAE,MAAM;QAAU,UAAU;QAAiB,QAAQ;IAAU;IAC/D;QAAE,MAAM;QAAU,UAAU;QAAiB,QAAQ;IAAQ;IAC7D;QAAE,MAAM;QAAU,UAAU;QAAiB,QAAQ;IAAQ;CAC9D"}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Alvaro/Desktop/Proyectos/wiki-realms/app/api/lastsales/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\r\nimport type { Sale } from '@/lib/lastsales'\r\nimport { readStored, writeStored, fetchOpenSeaSales, fetchRoninSales, fetchRoninGraphQLSales } from '@/lib/lastsales'\r\nimport { COLLECTIONS, OPENSEA_KEY, RONIN_API, RONIN_API_KEY } from '@/lib/lastsales-config'\r\n\r\nconst DAY_MS = 24 * 60 * 60 * 1000\r\nconst RONIN_RPC = process.env.RONIN_RPC_URL\r\n\r\nfunction withTimeout<T>(promise: Promise<T>, ms: number, message: string): Promise<T> {\r\n  let timer: ReturnType<typeof setTimeout>\r\n  return Promise.race([\r\n    promise,\r\n    new Promise<T>((_, reject) => {\r\n      timer = setTimeout(() => reject(new Error(message)), ms)\r\n    }),\r\n  ]).finally(() => clearTimeout(timer))\r\n}\r\n\r\nasync function collectAllSales(debugMode = false) {\r\n  const sales: Sale[] = []\r\n  const debug: Record<string, any> = {}\r\n\r\n  for (const col of COLLECTIONS) {\r\n    if (!col.contract) continue\r\n\r\n    try {\r\n      if (col.market === 'opensea') {\r\n        try {\r\n          const events = await withTimeout(fetchOpenSeaSales(col.contract, 0, OPENSEA_KEY), 7000, 'OpenSea timeout')\r\n          if (Array.isArray(events) && events.length) {\r\n            sales.push(...events)\r\n            if (debugMode) debug[`${col.name}:opensea`] = { count: events.length }\r\n          } else if (debugMode) {\r\n            debug[`${col.name}:opensea`] = { count: 0 }\r\n          }\r\n        } catch (err) {\r\n          if (debugMode) debug[`${col.name}:opensea_error`] = String(err)\r\n        }\r\n      } else if (col.market === 'ronin') {\r\n        let events: Sale[] = []\r\n        try {\r\n          if (RONIN_API) {\r\n            events = await withTimeout(\r\n              fetchRoninGraphQLSales(col.contract, RONIN_API, RONIN_API_KEY, 40, 0, debugMode),\r\n              15000,\r\n              'Ronin GraphQL timeout'\r\n            )\r\n          } else if (debugMode) {\r\n            debug[`${col.name}:ronin_warning`] = 'RONIN_API_URL is not configured'\r\n          }\r\n        } catch (err) {\r\n          if (debugMode) debug[`${col.name}:ronin_error`] = String(err)\r\n        }\r\n\r\n        if (!events || events.length === 0) {\r\n          try {\r\n            events = await fetchRoninSales(col.contract, 0, RONIN_RPC)\r\n            if (debugMode && events.length) debug[`${col.name}:ronin_rpc`] = { count: events.length }\r\n          } catch (err) {\r\n            if (debugMode) debug[`${col.name}:ronin_rpc_error`] = String(err)\r\n          }\r\n        }\r\n\r\n        if (Array.isArray(events) && events.length) {\r\n          sales.push(...events)\r\n          if (debugMode) debug[`${col.name}:ronin`] = { count: events.length }\r\n        }\r\n      }\r\n    } catch (err) {\r\n      if (debugMode) debug[`${col.name}:error`] = String(err)\r\n    }\r\n  }\r\n\r\n  return { sales, debug }\r\n}\r\n\r\nfunction persistSales(newSales: Sale[]) {\r\n  if (!Array.isArray(newSales) || newSales.length === 0) return\r\n\r\n  try {\r\n    const stored = readStored()\r\n    const byId = new Map<string, Sale>()\r\n\r\n    for (const sale of [...newSales, ...stored.sales]) {\r\n      if (!sale || !sale.id) continue\r\n      if (!byId.has(sale.id)) byId.set(sale.id, sale)\r\n    }\r\n\r\n    const merged = Array.from(byId.values())\r\n      .sort((a, b) => Date.parse(b.date) - Date.parse(a.date))\r\n      .slice(0, 5000)\r\n\r\n    const lastByCollection: Record<string, number> = {}\r\n    for (const sale of merged) {\r\n      const key = sale.collection || 'unknown'\r\n      const parsed = sale.date ? Date.parse(sale.date) : NaN\r\n      const ts = Number.isNaN(parsed) ? 0 : Math.floor(parsed / 1000)\r\n      if (ts <= 0) continue\r\n      if (!lastByCollection[key] || lastByCollection[key] < ts) lastByCollection[key] = ts\r\n    }\r\n\r\n    stored.sales = merged\r\n    stored.last_timestamps = lastByCollection\r\n    stored.last_refresh = Math.floor(Date.now() / 1000)\r\n    writeStored(stored)\r\n  } catch (err) {\r\n    // ignore persistence errors to keep the endpoint responsive\r\n  }\r\n}\r\n\r\nexport async function GET(request: Request) {\r\n  try {\r\n    const url = new URL(request.url)\r\n    const live = url.searchParams.get('live') === '1' || url.searchParams.get('live') === 'true'\r\n    const debugMode = url.searchParams.get('debug') === '1' || url.searchParams.get('debug') === 'true'\r\n    const persistFlag = url.searchParams.get('persist') === '1' || url.searchParams.get('persist') === 'true'\r\n\r\n    if (live) {\r\n      const { sales, debug } = await collectAllSales(debugMode)\r\n      if (persistFlag) persistSales(sales)\r\n      return debugMode ? NextResponse.json({ sales, debug }) : NextResponse.json({ sales })\r\n    }\r\n\r\n    let stored = readStored()\r\n    const lastRefresh = (stored.last_refresh || 0) * 1000\r\n    const stale = !stored.sales?.length || Date.now() - lastRefresh > DAY_MS\r\n\r\n    if (stale) {\r\n      try {\r\n        const { sales } = await collectAllSales(false)\r\n        if (sales.length) {\r\n          persistSales(sales)\r\n          stored = readStored()\r\n        }\r\n      } catch (err) {\r\n        // ignore refresh errors and fall back to cached data\r\n      }\r\n    }\r\n\r\n    return NextResponse.json(stored)\r\n  } catch (err) {\r\n    return NextResponse.json({ error: 'failed to read data' }, { status: 500 })\r\n  }\r\n}\r\n\r\nexport async function POST() {\r\n  try {\r\n    const { sales } = await collectAllSales(false)\r\n    if (sales.length) persistSales(sales)\r\n    return NextResponse.json({ ok: true, count: sales.length })\r\n  } catch (err) {\r\n    return NextResponse.json({ error: 'refresh failed' }, { status: 500 })\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}