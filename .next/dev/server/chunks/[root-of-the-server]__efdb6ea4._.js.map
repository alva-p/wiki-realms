{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Alvaro/Desktop/Proyectos/wiki-realms/lib/lastsales.ts"],"sourcesContent":["import fs from 'fs'\r\nimport path from 'path'\r\n\r\nconst DATA_PATH = path.resolve(process.cwd(), 'data', 'lastsales.json')\r\n\r\nexport type Trait = { trait_type: string; value: string }\r\n\r\nexport type Sale = {\r\n  id: string\r\n  collection: string\r\n  tokenId?: string\r\n  price: number\r\n  currency?: string\r\n  date: string\r\n  traits?: Trait[]\r\n}\r\n\r\ntype Stored = {\r\n  last_timestamps: Record<string, number>\r\n  sales: Sale[]\r\n}\r\n\r\nfunction ensureDataFile() {\r\n  const dir = path.dirname(DATA_PATH)\r\n  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true })\r\n  if (!fs.existsSync(DATA_PATH)) {\r\n    const initial: Stored = { last_timestamps: {}, sales: [] }\r\n    fs.writeFileSync(DATA_PATH, JSON.stringify(initial, null, 2))\r\n  }\r\n}\r\n\r\nexport function readStored(): Stored {\r\n  ensureDataFile()\r\n  const raw = fs.readFileSync(DATA_PATH, 'utf-8')\r\n  try {\r\n    return JSON.parse(raw) as Stored\r\n  } catch (err) {\r\n    const initial: Stored = { last_timestamps: {}, sales: [] }\r\n    return initial\r\n  }\r\n}\r\n\r\nexport function writeStored(data: Stored) {\r\n  ensureDataFile()\r\n  fs.writeFileSync(DATA_PATH, JSON.stringify(data, null, 2))\r\n}\r\n\r\n/**\r\n * Fetch sales from OpenSea events endpoint and normalize them to Sale[]\r\n */\r\nexport async function fetchOpenSeaSales(contract: string, occurredAfterUnix = 0, apiKey?: string): Promise<Sale[]> {\r\n  if (!contract) return []\r\n\r\n  const base = 'https://api.opensea.io/api/v1/events'\r\n  const url = new URL(base)\r\n  url.searchParams.set('asset_contract_address', contract)\r\n  url.searchParams.set('event_type', 'successful')\r\n  url.searchParams.set('only_opensea', 'false')\r\n  if (occurredAfterUnix) url.searchParams.set('occurred_after', String(occurredAfterUnix))\r\n  url.searchParams.set('limit', '50')\r\n\r\n  const headers: Record<string, string> = {}\r\n  if (apiKey) headers['X-API-KEY'] = apiKey\r\n\r\n  const res = await fetch(url.toString(), { headers })\r\n  if (!res.ok) throw new Error(`OpenSea fetch failed: ${res.status}`)\r\n  const data = await res.json()\r\n\r\n  const events = data?.asset_events || []\r\n  const normalized: Sale[] = events.map((e: any) => {\r\n    const asset = e?.asset || (e?.asset_bundle?.assets && e.asset_bundle.assets[0])\r\n    const tokenId = asset?.token_id || e?.asset_bundle?.slug || undefined\r\n    const totalPrice = e?.total_price ?? e?.payment_token?.usd_price ?? '0'\r\n    const decimals = e?.payment_token?.decimals ?? 18\r\n    const price = Number(totalPrice) / Math.pow(10, decimals)\r\n    const date = e?.transaction?.timestamp || e?.created_date\r\n    const traits = (asset?.traits || []).map((t: any) => ({ trait_type: t.trait_type, value: t.value }))\r\n\r\n    return {\r\n      id: String(e.id || `${contract}-${tokenId}-${date}`),\r\n      collection: asset?.collection?.name || asset?.collection?.slug || e?.collection?.slug || contract,\r\n      tokenId,\r\n      price: Number.isFinite(price) ? price : 0,\r\n      currency: e?.payment_token?.symbol || undefined,\r\n      date,\r\n      traits,\r\n    }\r\n  })\r\n\r\n  return normalized\r\n}\r\n\r\n/**\r\n * Refresh all configured collections. The COLLECTIONS list should be provided by the caller\r\n * as an array of { name, contract, market, last_timestamp? }.\r\n */\r\nexport async function refreshCollections(collections: { name?: string; contract?: string; market?: string; last_timestamp?: number }[], apiKey?: string) {\r\n  const stored = readStored()\r\n\r\n  for (const col of collections) {\r\n    const key = col.contract || col.name || 'unknown'\r\n    const last = stored.last_timestamps[key] || (col.last_timestamp || 0)\r\n\r\n    try {\r\n      const events = await fetchOpenSeaSales(col.contract || '', last, apiKey)\r\n      if (!events.length) continue\r\n\r\n      // append new events (avoid duplicates by id)\r\n      const existingIds = new Set(stored.sales.map((s) => s.id))\r\n      const toAdd = events.filter((e) => !existingIds.has(e.id))\r\n      stored.sales = [...toAdd, ...stored.sales].slice(0, 5000) // cap\r\n\r\n      // update last timestamp to newest event\r\n      const newest = Math.max(...events.map((e) => Date.parse(e.date) / 1000 || 0))\r\n      stored.last_timestamps[key] = Math.max(stored.last_timestamps[key] || 0, newest)\r\n    } catch (err) {\r\n      // swallow per-collection errors so one failure doesn't stop the whole refresh\r\n      // In production log this properly\r\n      // console.error('refreshCollections error', err)\r\n    }\r\n  }\r\n\r\n  writeStored(stored)\r\n  return stored\r\n}\r\n\r\nexport default {\r\n  readStored,\r\n  writeStored,\r\n  fetchOpenSeaSales,\r\n  refreshCollections,\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Alvaro/Desktop/Proyectos/wiki-realms/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\ndeclare global {\r\n  // allow global prisma during dev to avoid multiple clients\r\n  // eslint-disable-next-line no-var\r\n  var __prisma: PrismaClient | undefined\r\n}\r\n\r\nconst prisma = global.__prisma || new PrismaClient()\r\nif (process.env.NODE_ENV === 'development') global.__prisma = prisma\r\n\r\nexport default prisma\r\n"],"names":[],"mappings":";;;;;;;;;;AAQA,MAAM,SAAS,OAAO,QAAQ,IAAI,IAAI;AACtC,wCAA4C,OAAO,QAAQ,GAAG;uCAE/C"}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Alvaro/Desktop/Proyectos/wiki-realms/lib/lastsales_db.ts"],"sourcesContent":["import prisma from './prisma'\r\nimport { fetchOpenSeaSales } from './lastsales'\r\n\r\nexport async function readSalesFromDb() {\r\n  const rows = await prisma.sale.findMany({ orderBy: { date: 'desc' }, take: 5000 })\r\n  return rows.map((r) => ({\r\n    id: r.id,\r\n    collection: r.collection,\r\n    tokenId: r.tokenId || undefined,\r\n    price: r.price,\r\n    currency: r.currency || undefined,\r\n    date: r.date.toISOString(),\r\n    traits: r.traits as any,\r\n  }))\r\n}\r\n\r\nexport async function upsertCollectionState(contract: string, name?: string, market?: string, lastTimestamp = 0) {\r\n  return prisma.collectionState.upsert({\r\n    where: { contract },\r\n    update: { name, market, lastTimestamp },\r\n    create: { contract, name, market, lastTimestamp },\r\n  })\r\n}\r\n\r\nexport async function getCollectionState(contract: string) {\r\n  return prisma.collectionState.findUnique({ where: { contract } })\r\n}\r\n\r\nexport async function writeSalesToDb(sales: any[]) {\r\n  // insert many (skip existing by id)\r\n  for (const s of sales) {\r\n    await prisma.sale.upsert({\r\n      where: { id: s.id },\r\n      update: { price: s.price, updatedAt: new Date() },\r\n      create: {\r\n        id: s.id,\r\n        collection: s.collection || 'unknown',\r\n        tokenId: s.tokenId || null,\r\n        price: s.price || 0,\r\n        currency: s.currency || null,\r\n        date: new Date(s.date),\r\n        traits: s.traits || null,\r\n      },\r\n    })\r\n  }\r\n}\r\n\r\nexport async function refreshCollectionsDb(collections: { name?: string; contract?: string; market?: string; last_timestamp?: number }[], apiKey?: string) {\r\n  for (const col of collections) {\r\n    const state = await getCollectionState(col.contract || '')\r\n    const last = state?.lastTimestamp || (col.last_timestamp || 0)\r\n    const events = await fetchOpenSeaSales(col.contract || '', last, apiKey)\r\n    if (!events.length) continue\r\n    await writeSalesToDb(events)\r\n    const newest = Math.max(...events.map((e) => Date.parse(e.date) / 1000 || 0))\r\n    await upsertCollectionState(col.contract || '', col.name, col.market, Math.max(last, newest))\r\n  }\r\n}\r\n\r\nexport default {\r\n  readSalesFromDb,\r\n  writeSalesToDb,\r\n  refreshCollectionsDb,\r\n  upsertCollectionState,\r\n  getCollectionState,\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM,oKAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;QAAE,SAAS;YAAE,MAAM;QAAO;QAAG,MAAM;IAAK;IAChF,OAAO,KAAK,GAAG,CAAC,CAAC,IAAM,CAAC;YACtB,IAAI,EAAE,EAAE;YACR,YAAY,EAAE,UAAU;YACxB,SAAS,EAAE,OAAO,IAAI;YACtB,OAAO,EAAE,KAAK;YACd,UAAU,EAAE,QAAQ,IAAI;YACxB,MAAM,EAAE,IAAI,CAAC,WAAW;YACxB,QAAQ,EAAE,MAAM;QAClB,CAAC;AACH;AAEO,eAAe,sBAAsB,QAAgB,EAAE,IAAa,EAAE,MAAe,EAAE,gBAAgB,CAAC;IAC7G,OAAO,oKAAM,CAAC,eAAe,CAAC,MAAM,CAAC;QACnC,OAAO;YAAE;QAAS;QAClB,QAAQ;YAAE;YAAM;YAAQ;QAAc;QACtC,QAAQ;YAAE;YAAU;YAAM;YAAQ;QAAc;IAClD;AACF;AAEO,eAAe,mBAAmB,QAAgB;IACvD,OAAO,oKAAM,CAAC,eAAe,CAAC,UAAU,CAAC;QAAE,OAAO;YAAE;QAAS;IAAE;AACjE;AAEO,eAAe,eAAe,KAAY;IAC/C,oCAAoC;IACpC,KAAK,MAAM,KAAK,MAAO;QACrB,MAAM,oKAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACvB,OAAO;gBAAE,IAAI,EAAE,EAAE;YAAC;YAClB,QAAQ;gBAAE,OAAO,EAAE,KAAK;gBAAE,WAAW,IAAI;YAAO;YAChD,QAAQ;gBACN,IAAI,EAAE,EAAE;gBACR,YAAY,EAAE,UAAU,IAAI;gBAC5B,SAAS,EAAE,OAAO,IAAI;gBACtB,OAAO,EAAE,KAAK,IAAI;gBAClB,UAAU,EAAE,QAAQ,IAAI;gBACxB,MAAM,IAAI,KAAK,EAAE,IAAI;gBACrB,QAAQ,EAAE,MAAM,IAAI;YACtB;QACF;IACF;AACF;AAEO,eAAe,qBAAqB,WAA6F,EAAE,MAAe;IACvJ,KAAK,MAAM,OAAO,YAAa;QAC7B,MAAM,QAAQ,MAAM,mBAAmB,IAAI,QAAQ,IAAI;QACvD,MAAM,OAAO,OAAO,iBAAkB,IAAI,cAAc,IAAI;QAC5D,MAAM,SAAS,MAAM,IAAA,iLAAiB,EAAC,IAAI,QAAQ,IAAI,IAAI,MAAM;QACjE,IAAI,CAAC,OAAO,MAAM,EAAE;QACpB,MAAM,eAAe;QACrB,MAAM,SAAS,KAAK,GAAG,IAAI,OAAO,GAAG,CAAC,CAAC,IAAM,KAAK,KAAK,CAAC,EAAE,IAAI,IAAI,QAAQ;QAC1E,MAAM,sBAAsB,IAAI,QAAQ,IAAI,IAAI,IAAI,IAAI,EAAE,IAAI,MAAM,EAAE,KAAK,GAAG,CAAC,MAAM;IACvF;AACF;uCAEe;IACb;IACA;IACA;IACA;IACA;AACF"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Alvaro/Desktop/Proyectos/wiki-realms/app/api/lastsales/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\r\nimport { readStored, refreshCollections } from '@/lib/lastsales'\r\nimport db from '@/lib/lastsales_db'\r\nimport prisma from '@/lib/prisma'\r\n\r\nconst CONTRACT_KOJINS = process.env.CONTRACT_ADDRESS_KOJINS\r\nconst CONTRACT_MOUNTS = process.env.CONTRACT_ADDRESS_MOUNTS\r\nconst OPENSEA_KEY = process.env.OPENSEA_API_KEY\r\n\r\nconst COLLECTIONS = [\r\n  { name: 'Kojins', contract: CONTRACT_KOJINS, market: 'opensea' },\r\n  { name: 'Mounts', contract: CONTRACT_MOUNTS, market: 'opensea' },\r\n]\r\n\r\nexport async function GET() {\r\n  try {\r\n    // Prefer DB if configured\r\n    if (process.env.DATABASE_URL) {\r\n      const sales = await db.readSalesFromDb()\r\n      return NextResponse.json({ sales })\r\n    }\r\n\r\n    const data = readStored()\r\n    return NextResponse.json(data)\r\n  } catch (err) {\r\n    return NextResponse.json({ error: 'failed to read data' }, { status: 500 })\r\n  }\r\n}\r\n\r\nexport async function POST() {\r\n  // Trigger a refresh of the configured collections\r\n  try {\r\n    if (process.env.DATABASE_URL) {\r\n      await db.refreshCollectionsDb(COLLECTIONS, OPENSEA_KEY)\r\n      return NextResponse.json({ ok: true })\r\n    }\r\n\r\n    const result = await refreshCollections(COLLECTIONS, OPENSEA_KEY)\r\n    return NextResponse.json({ ok: true, result })\r\n  } catch (err) {\r\n    return NextResponse.json({ error: 'refresh failed' }, { status: 500 })\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAGA,MAAM,kBAAkB,QAAQ,GAAG,CAAC,uBAAuB;AAC3D,MAAM,kBAAkB,QAAQ,GAAG,CAAC,uBAAuB;AAC3D,MAAM,cAAc,QAAQ,GAAG,CAAC,eAAe;AAE/C,MAAM,cAAc;IAClB;QAAE,MAAM;QAAU,UAAU;QAAiB,QAAQ;IAAU;IAC/D;QAAE,MAAM;QAAU,UAAU;QAAiB,QAAQ;IAAU;CAChE;AAEM,eAAe;IACpB,IAAI;QACF,0BAA0B;QAC1B,IAAI,QAAQ,GAAG,CAAC,YAAY,EAAE;YAC5B,MAAM,QAAQ,MAAM,0KAAE,CAAC,eAAe;YACtC,OAAO,yTAAY,CAAC,IAAI,CAAC;gBAAE;YAAM;QACnC;QAEA,MAAM,OAAO,IAAA,0KAAU;QACvB,OAAO,yTAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,KAAK;QACZ,OAAO,yTAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAsB,GAAG;YAAE,QAAQ;QAAI;IAC3E;AACF;AAEO,eAAe;IACpB,kDAAkD;IAClD,IAAI;QACF,IAAI,QAAQ,GAAG,CAAC,YAAY,EAAE;YAC5B,MAAM,0KAAE,CAAC,oBAAoB,CAAC,aAAa;YAC3C,OAAO,yTAAY,CAAC,IAAI,CAAC;gBAAE,IAAI;YAAK;QACtC;QAEA,MAAM,SAAS,MAAM,IAAA,kLAAkB,EAAC,aAAa;QACrD,OAAO,yTAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM;QAAO;IAC9C,EAAE,OAAO,KAAK;QACZ,OAAO,yTAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;AACF"}}]
}